## Welcome to Samantha Coyle's Research Page

This research was started Spring 2018 with Mr. Greg LaKomski and Dr. Apan Qasem of Texas State University.

### Motivation

Algorithmic efficiency has become hugely important due to the need to analyze massive data sets generated by cloud computing and the Internet of Things. While making algorithms more succinct and comprehensive, recursion can also be highly inefficient when applied to these data sets. As an alternative to recursion in many applications, dynamic programming techniques can significantly improve runtime efficiency. Although runtime efficiency has been widely studied for specific problem applications, less attention has been given to the relationship of language and underlying architecture to a broader measure of efficiency that includes both runtime and resource consumption. This investigation explores and compares runtime efficiency and resource consumption for both recursive and dynamic programming across several different programming languages that abstract widely differing architectural elements. In order to get a broad understanding of the relationship between recursive algorithms and dynamic algorithms, the widely applicable Fibonacci algorithm was chosen as a simple means of keeping the algorithm as constant as possible, while maintaining feasibility for the monitoring of resources across several programming languages. A full comparison of all studied languages is presented, the potential factors behind the results analyzed and the possible ramifications for actual use discussed.

### Objectives
- Learn about profile monitoring utilities for complex processes
- Access the functionality and limitations of the perf command line resource monitoring utility
- Gain an understanding of the architectural differences among a variety of programming languages, to include compiled versus interpreted
- Determine how programming languages with differing architectural components affect runtime, task-clock time, CPU-cycles, instruction count, page-faults, and cache-misses
- Analyze how recursive algorithms compare to dynamic algorithms in resource consumption and runtime efficiency

### Methodology

1. Set up the environment
- Figure out the kind of machine you are going to perform on. Ensure all programming languages and performance monitoring utilities are installed and up-to-date.
2. Execution
- Utilize a Fibonacci algorithm for both the recursive and dynamic algorithm. Execute the programs utilizing Fibonacci numbers of 20, 30, 40, and 50, gathering data on runtime, CPU-cycles, task-clock rates, instruction counts, clock rate, page-faults, cache-misses, % of all cache refs, and speedup.
3. Analysis
- Compare the results across the various programming languages tested, and in terms of the dynamic algorithm, versus the recursive algorithm.
- Focus on C++ vs Python

### Algorithm Results
#### Observations
The overall runtime for the recursive algorithms were larger than the dynamic algorithm runtimes. The overall trend for the recursive algorithms included an increase in resource consumption for the Fibonacci numbers of 30 and 40, whereas the dynamic algorithm results trended mostly linearly.

#### Analysis
Because of the characteristics of recursive algorithms, it is expected for the runtimes to be slower as there is higher overhead from the call stack being used so heavily. Furthermore, programs are bounded by physical memory, so it is likely that Perl, Python, and Go reached their limit. Otherwise, as the compiler was setting up the activation records, it was trying to do something fancy with the algorithm; thus, causing issues for the runtimes. The dynamic algorithm did not have these issues as there is little overhead. The CPU-cycles may have been reported incorrectly as perf is sample based, and does not count every cycle. It is likely the programs ran too fast and perf didn’t catch all of the CPU-cycles. In addition, the task-clock and instruction count results can be explained by the higher overhead. For larger Fibonacci numbers, it became unfeasible to calculate the resources as the stack grew too large for the recursive algorithm. The dynamic algorithms were more linear as the resources needed to calculate the larger Fibonacci numbers became higher, because more resources are necessary to deal with larger input values.



```markdown

```


### Jekyll Themes

Your Pages site will use the layout and styles from the Jekyll theme you have selected in your [repository settings](https://github.com/sicoyle/Research/settings). The name of this theme is saved in the Jekyll `_config.yml` configuration file.

### Support or Contact

Having trouble with Pages? Check out our [documentation](https://help.github.com/categories/github-pages-basics/) or [contact support](https://github.com/contact) and we’ll help you sort it out.
